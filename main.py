# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'tds2.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QMainWindow, QFileDialog, QPushButton, QMenu, QAction, QMessageBox, QDialog, QVBoxLayout,QTextEdit, QLabel, QLineEdit, QTabWidget, QGridLayout, QTableWidget, QTableWidgetItem
from PyQt5.QtCore import QFile, QTextStream, QThreadPool, QJsonDocument
from PyQt5 import QtCore
from PyQt5.QtCore import Qt
import threading
import requests
from tiktok import SeleniumWorker
import time
import traceback
from PyQt5.QtGui import QPixmap, QIntValidator
from pathlib import Path
import json
import os
from proxy_chrome_driver import get_chromedriver
from tiktok_socket import TiktokSocketWorker

from functools import partial
from adb_ultils import ADB
from emulator_adb_backup import start_worker
from emulator_adb import EmulatorWorker

class PasswordDelegate(QtWidgets.QStyledItemDelegate):
    def initStyleOption(self, option, index):
        super().initStyleOption(option, index)
        style = option.widget.style() or QtWidgets.QApplication.style()
        hint = style.styleHint(QtWidgets.QStyle.SH_LineEdit_PasswordCharacter)
        option.text = chr(hint) * len(option.text)

class AddCategoryDialog(QDialog):
    def __init__(self, parent=None):
        super(AddCategoryDialog, self).__init__(parent)
        self.setWindowTitle("Add new category")
        self.setGeometry(400, 200, 300, 100)

        self.label = QLabel("Nhập category mới:")
        self.text_input = QLineEdit(self)
        self.ok_button = QPushButton("Lưu", self)

        layout = QVBoxLayout(self)
        layout.addWidget(self.label)
        layout.addWidget(self.text_input)
        layout.addWidget(self.ok_button)

        self.ok_button.clicked.connect(self.accept)
    
class RemoveCategoryDialog(QDialog):
    def __init__(self, parent=None):
        super(AddCategoryDialog, self).__init__(parent)
        self.setWindowTitle("Add new category")
        self.setGeometry(400, 200, 300, 100)

        self.label = QLabel("Nhập category mới:")
        self.text_input = QLineEdit(self)
        self.ok_button = QPushButton("Lưu", self)

        layout = QVBoxLayout(self)
        layout.addWidget(self.label)
        layout.addWidget(self.text_input)
        layout.addWidget(self.ok_button)

        self.ok_button.clicked.connect(self.accept)

class Ui_MainWindow(object):

    def __init__(self):
        self.column_order = ["username", "password","email", "email_password", "cookie", "token", "profile_status", "proxy", "status"]
        self.worker_column_order = ["username", "device_id", "app_order", "started_time", "interaction_quantity", "status", "actions"]
        self.device_column_order = ["name", "connected_order"]

        self.accounts = {}
        self.cloned_accounts = {}

        self.base_url = "https://traodoisub.com"

        # New
        # threadpool_1 to make a connection to a Livestream
        self.threadpool_1 = QThreadPool()
        # Set the maximum number of threads (workers)
        self.threadpool_1.setMaxThreadCount(1)

        # threadpool_2 to do works
        self.threadpool_2 = QThreadPool()
        # Set the maximum number of threads (workers)
        self.threadpool_2.setMaxThreadCount(4)
        print("Multithreading with maximum %d threads" % self.threadpool_2.maxThreadCount())

        # New
        self.check_mark_img = './images/check-mark-16.jpg'
        self.x_mark_img = './images/x-mark-16.jpg'

        # New - 1/1/2024
        self.selected_rows_count = 0
        self.running_threads = 0
        self.waiting_threads = 0
        self.completed_threads = 0

        # NEW 19 - 1 - 2024
        # self.phone_device = {
        #     "ce011711e365a00304": {
        #         "name": "ce011711e365a00304",
        #         "status": "free"
        #     },
        #     "ce011711e365a00306": {
        #         "name": "ce011711e365a00306",
        #         "status": "busy"
        #     }
	    # }

        self.phone_devices = {}
        devices = ADB.get_devices()
        if devices is not None:
            for device in devices:
                temp = {}
                temp["name"] = device
                temp["status"] = "free" # Initilize status free
                temp["accounts"] = []
                self.phone_devices[device] = temp


        
        # ? All workers: int is unix time
        self.waiting_workers: list[str, EmulatorWorker] = {}
        self.running_workers : list(str, EmulatorWorker) = {}
        self.completed_workers : list(str, EmulatorWorker) = {}


    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")

        # Size of the main window
        MainWindow.resize(1690, 900)


        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        # NEW TAB
        self.tabWidget = QtWidgets.QTabWidget(self.centralwidget)
        self.tabWidget.setGeometry(QtCore.QRect(0, 0, 1739, 1100))
        self.tabWidget.setObjectName("tabWidget")

        self.actionTab = QtWidgets.QWidget()
        self.actionTab.setObjectName("actionTab")


        self.addAccountButton = QtWidgets.QPushButton(self.actionTab)
        self.addAccountButton.setGeometry(QtCore.QRect(28, 20, 101, 31))
        self.addAccountButton.setObjectName("addAccountButton")

        self.addProxyButton = QtWidgets.QPushButton(self.actionTab)
        self.addProxyButton.setGeometry(QtCore.QRect(130, 20, 101, 31))
        self.addProxyButton.setObjectName("addProxyButton")

        # NEW
        self.saveProfiles = QtWidgets.QPushButton(self.actionTab)
        self.saveProfiles.setGeometry(QtCore.QRect(232, 20, 101, 31))
        self.saveProfiles.setObjectName("saveProfiles")

        # self.importConfig = QtWidgets.QPushButton(self.centralwidget)
        # self.importConfig.setGeometry(QtCore.QRect(334, 20, 101, 31))
        # self.importConfig.setObjectName("importConfig")

        self.interactTiktok = QtWidgets.QPushButton(self.actionTab)
        self.interactTiktok.setGeometry(QtCore.QRect(334, 20, 101, 31))
        self.interactTiktok.setObjectName("interactTiktok")


        

        self.tableWidget = QtWidgets.QTableWidget(self.actionTab)
        # 3rd and 4th parameters use to set width and height of the Table Widget
        self.tableWidget.setGeometry(QtCore.QRect(30, 130, 1616, 639))


        self.tableWidget.setObjectName("tableWidget")

        # Set column count
        self.tableWidget.setColumnCount(10)

        # self.tableWidget.setRowCount(2)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setVerticalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setVerticalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()

        self.tableWidget.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(3, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(4, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(5, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(6, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(7, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(8, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(9, item)

        # set all column width
        # self.set_column_width()


        # Set specified width for column "Username"
        self.tableWidget.setColumnWidth(0, 129)

        # Set specified width for column "Password"
        self.tableWidget.setColumnWidth(1, 129)

        # Set specified width for column "Email"
        self.tableWidget.setColumnWidth(2, 200)

        # Set specified width for column "Email Password"
        self.tableWidget.setColumnWidth(3, 129)

        # Set specified width for column "Cookie"
        self.tableWidget.setColumnWidth(4, 129)

        # Set specified width for column "Token"
        self.tableWidget.setColumnWidth(5, 129)

        # Set specified width for column "Profile Status"
        self.tableWidget.setColumnWidth(6, 129)

        # Set specified width for column "proxy"
        self.tableWidget.setColumnWidth(7, 134)

        # Set specified width for column "received jobs"
        self.tableWidget.setColumnWidth(8, 123)


        # Set specified width for column "status"
        self.tableWidget.setColumnWidth(9, 360)


        # Set row height
        self.tableWidget.verticalHeader().setDefaultSectionSize(30)

        # Label "File:""
        self.filterLabel = QtWidgets.QLabel(self.actionTab)
        self.filterLabel.setGeometry(QtCore.QRect(30, 90, 20, 16))
        self.filterLabel.setObjectName("filterLabel")

        # Combobox "category"
        self.category = QtWidgets.QComboBox(self.actionTab)
        self.category.setGeometry(QtCore.QRect(54, 89, 120, 21))
        self.category.setObjectName("category")
        self.category.addItem("All category")

        # Button choose category options
        self.categoryOptions = QtWidgets.QPushButton(self.actionTab)
        self.categoryOptions.setGeometry(QtCore.QRect(179, 91, 20, 18))
        self.categoryOptions.setObjectName("categoryOptions")

        # NEW 6/1
        self.widget = QtWidgets.QWidget(self.actionTab)
        self.widget.setGeometry(QtCore.QRect(180, 110, 109, 58))
        self.widget.setObjectName("widget")
        self.widget.setStyleSheet("background-color: #eeeee4;")
        self.AddCategory = QtWidgets.QPushButton(self.widget)
        self.AddCategory.setGeometry(QtCore.QRect(5, 4, 99, 23))
        self.AddCategory.setObjectName("AddCategory")
        self.AddCategory.setStyleSheet("background-color: white;")
        self.RemoveCategory = QtWidgets.QPushButton(self.widget)
        self.RemoveCategory.setGeometry(QtCore.QRect(5, 29, 99, 23))
        self.RemoveCategory.setObjectName("RemoveCategory")
        self.RemoveCategory.setStyleSheet("background-color: white;")

        # Label "Total selected rows:"
        self.totalSelectedRows = QtWidgets.QLabel(self.actionTab)
        self.totalSelectedRows.setGeometry(QtCore.QRect(30, 779, 741, 16))
        self.totalSelectedRows.setObjectName("totalSelectedRows")

        # Label "Total selected rows:"
        self.totalRunningRows = QtWidgets.QLabel(self.actionTab)
        self.totalRunningRows.setGeometry(QtCore.QRect(30, 799, 741, 16))
        self.totalRunningRows.setObjectName("totalRunningRows")

        # Label "Total selected rows:"
        self.totalWaitingRows = QtWidgets.QLabel(self.actionTab)
        self.totalWaitingRows.setGeometry(QtCore.QRect(30, 819, 741, 16))
        self.totalWaitingRows.setObjectName("totalWaitingRows")

        # Label "Total selected rows:"
        self.totalCompletedRows = QtWidgets.QLabel(self.actionTab)
        self.totalCompletedRows.setGeometry(QtCore.QRect(30, 839, 741, 16))
        self.totalCompletedRows.setObjectName("totalCompletedRows")

        MainWindow.setCentralWidget(self.actionTab)

        # NEW - Right click menu
        self.tableWidget.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tableWidget.customContextMenuRequested.connect(self.showContextMenu)


        # new
        self.addAccountButton.clicked.connect(self.show_add_accounts_dialog)
        self.addProxyButton.clicked.connect(self.show_add_proxies_dialog)
        self.saveProfiles.clicked.connect(self.save_profiles)
        self.interactTiktok.clicked.connect(self.interact_tiktok)
        
        # New 6/1
        self.category.currentTextChanged.connect(self.update_table)
        self.categoryOptions.clicked.connect(self.toggle_category_options)
        self.AddCategory.clicked.connect(self.show_add_new_category)
        self.RemoveCategory.clicked.connect(self.show_confirm_remove_category)
        # New
        self.tempTableWidget = QtWidgets.QTableWidget()
        self.tabWidget.addTab(self.actionTab, "")

        # TAB CONFIG TIKTOK JOB
        self.jobConfiguration = QtWidgets.QWidget()
        self.jobConfiguration.setObjectName("jobConfiguration")
        self.livestreamLabel = QtWidgets.QLabel(self.jobConfiguration)
        self.livestreamLabel.setGeometry(QtCore.QRect(30, 30, 101, 16))
        self.livestreamLabel.setObjectName("livestreamLabel")

        self.livestreamIdEdit = QtWidgets.QLineEdit(self.jobConfiguration)
        self.livestreamIdEdit.setGeometry(QtCore.QRect(130, 30, 140, 20))
        self.livestreamIdEdit.setObjectName("lineEdit")
        
        self.reLivestreamLabel = QtWidgets.QLabel(self.jobConfiguration)
        self.reLivestreamLabel.setGeometry(QtCore.QRect(280, 30, 91, 16))
        self.reLivestreamLabel.setObjectName("reLivestreamLabel")
        self.reLivestreamIdEdit = QtWidgets.QLineEdit(self.jobConfiguration)
        self.reLivestreamIdEdit.setGeometry(QtCore.QRect(370, 30, 140, 20))
        self.reLivestreamIdEdit.setObjectName("livestreamIdEdit")

        self.delayTimeLabel = QtWidgets.QLabel(self.jobConfiguration)
        self.delayTimeLabel.setGeometry(QtCore.QRect(520, 30, 61, 16))
        self.delayTimeLabel.setObjectName("delayTimeLabel")

        self.delayTimeEdit = QtWidgets.QLineEdit(self.jobConfiguration)
        self.delayTimeEdit.setGeometry(QtCore.QRect(584, 30, 51, 20))
        self.delayTimeEdit.setObjectName("delayTimeEdit")

        self.commentTable = QtWidgets.QTableWidget(self.jobConfiguration)
        self.commentTable.setGeometry(QtCore.QRect(30, 100, 1021, 431))
        self.commentTable.setObjectName("commentTable")
        self.commentTable.setColumnCount(3)
        self.commentTable.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.commentTable.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.commentTable.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.commentTable.setHorizontalHeaderItem(2, item)
        # self.tabWidget.addTab(self.jobConfiguration, "")
        

        self.innerWorkTabWidget = QtWidgets.QTabWidget()
        self.innerWorkTabWidget.setGeometry(QtCore.QRect(0, 0, 1739, 1100))
        self.innerWorkTabWidget.setObjectName("innerWorkTabWidget")
        self.innerWorkTabWidget.addTab(self.jobConfiguration, "")
        self.tabWidget.addTab(self.innerWorkTabWidget, "")



        

        # TAB TIKTOK INTERACTIONS (throw heart)
        self.tab_3 = QtWidgets.QWidget()
        self.tab_3.setObjectName("tab_3")
        self.t3LiveSrcLabel = QtWidgets.QLabel(self.tab_3)
        self.t3LiveSrcLabel.setGeometry(QtCore.QRect(10, 20, 100, 16))
        self.t3LiveSrclineEdit = QtWidgets.QLineEdit(self.tab_3)
        self.t3LiveSrclineEdit.setGeometry(QtCore.QRect(110, 20, 113, 20))
        self.t3LiveSrclineEdit.setObjectName("lineEdit")
        self.t3WorkTimeLabel = QtWidgets.QLabel(self.tab_3)
        self.t3WorkTimeLabel.setGeometry(QtCore.QRect(240, 20, 86, 16))
        self.t3WorkTimeLabel.setObjectName("t3WorkTimeLabel")
        self.t3WorkTimelineEdit = QtWidgets.QLineEdit(self.tab_3)
        self.t3WorkTimelineEdit.setGeometry(QtCore.QRect(328, 20, 39, 20))
        self.t3WorkTimelineEdit.setObjectName("t3WorkTimelineEdit")
        self.t3LiveStatusLabel = QtWidgets.QLabel(self.tab_3)
        self.t3LiveStatusLabel.setGeometry(QtCore.QRect(390, 20, 55, 16))
        self.t3LiveStatusLabel.setObjectName("t3LiveStatusLabel")
        self.t3LiveStatusLineEdit = QtWidgets.QLineEdit(self.tab_3)
        self.t3LiveStatusLineEdit.setGeometry(QtCore.QRect(448, 20, 300, 20))
        self.t3LiveStatusLineEdit.setObjectName("t3WorkTimelineEdit")
        self.t3LiveStatusLineEdit.setEnabled(False)
        self.t3EditConfigBtn = QtWidgets.QPushButton(self.tab_3)
        self.t3EditConfigBtn.setGeometry(QtCore.QRect(820, 20, 80, 23))
        self.t3EditConfigBtn.setObjectName("t3EditConfigBtn")
        self.t3SaveConfigBtn = QtWidgets.QPushButton(self.tab_3)
        self.t3SaveConfigBtn.setGeometry(QtCore.QRect(900, 20, 51, 23))
        self.t3SaveConfigBtn.setObjectName("t3SaveConfigBtn")

        # T3 - Label "File:""
        self.t3_filterLabel = QtWidgets.QLabel(self.tab_3)
        self.t3_filterLabel.setGeometry(QtCore.QRect(10, 55, 20, 16))
        self.t3_filterLabel.setObjectName("t3_filterLabel")

        # T3 - Combobox "category"
        self.t3_category = QtWidgets.QComboBox(self.tab_3)
        self.t3_category.setGeometry(QtCore.QRect(2000, 54, 120, 21))
        self.t3_category.setObjectName("t3_category")
        self.t3_category.addItem("All category")

        self.t3_category.currentTextChanged.connect(self.update_table)

        self.t3_cloneAccountBtn = QtWidgets.QPushButton(self.tab_3)
        self.t3_cloneAccountBtn.setGeometry(QtCore.QRect(10, 54, 100, 23))
        self.t3_cloneAccountBtn.setObjectName("t3_cloneAccountBtn")
        self.t3_cloneAccountBtn.clicked.connect(self.t3_ShowDialogCloneAccounts)

        self.t3_configureDeviceBtn = QtWidgets.QPushButton(self.tab_3)
        self.t3_configureDeviceBtn.setGeometry(QtCore.QRect(120, 54, 100, 23))
        self.t3_configureDeviceBtn.setObjectName("t3_configureDeviceBtn")
        self.t3_configureDeviceBtn.clicked.connect(self.t3_ShowDialogConfigDevices)
        self.t3_configureDeviceBtn.setEnabled(False)
        

        # T3 - Label "Connectted Devices:"
        self.t3_connectedDevicesLabel = QtWidgets.QLabel(self.tab_3)
        self.t3_connectedDevicesLabel.setGeometry(QtCore.QRect(768, 55, 100, 16))
        self.t3_connectedDevicesLabel.setObjectName("t3_connectedDevicesLabel")
        self.t3_connectedDevicesLineEdit = QtWidgets.QLineEdit(self.tab_3)
        self.t3_connectedDevicesLineEdit.setGeometry(QtCore.QRect(868, 54, 20, 20))
        self.t3_connectedDevicesLineEdit.setEnabled(False)
        self.t3_reloadDevicesBtn = QtWidgets.QPushButton(self.tab_3)
        self.t3_reloadDevicesBtn.setGeometry(QtCore.QRect(900, 54, 51, 23))
        self.t3_reloadDevicesBtn.setObjectName("t3_reloadDevicesBtn")




        self.t3tableWidget = QtWidgets.QTableWidget(self.tab_3)
        self.t3tableWidget.setGeometry(QtCore.QRect(10, 88, 1616, 680))
        self.t3tableWidget.setObjectName("t3tableWidget")
        self.t3tableWidget.setColumnCount(10)
        self.t3tableWidget.setRowCount(26)
        item = QtWidgets.QTableWidgetItem()
        self.t3tableWidget.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.t3tableWidget.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.t3tableWidget.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.t3tableWidget.setHorizontalHeaderItem(3, item)
        item = QtWidgets.QTableWidgetItem()
        self.t3tableWidget.setHorizontalHeaderItem(4, item)
        item = QtWidgets.QTableWidgetItem()
        self.t3tableWidget.setHorizontalHeaderItem(5, item)
        item = QtWidgets.QTableWidgetItem()
        self.t3tableWidget.setHorizontalHeaderItem(6, item)
        self.t3tableWidget.setColumnWidth(0, 150)
        self.t3tableWidget.setColumnWidth(1, 150)
        self.t3tableWidget.setColumnWidth(2, 120)
        self.t3tableWidget.setColumnWidth(3, 120)
        self.t3tableWidget.setColumnWidth(4, 120)
        self.t3tableWidget.setColumnWidth(5, 400)
        self.t3tableWidget.setColumnWidth(6, 120)


        self.t3tableWidget.setSelectionMode(QTableWidget.MultiSelection)
        self.t3tableWidget.itemSelectionChanged.connect(self.selection_changed)

        self.t3SaveConfigBtn.clicked.connect(self.t3_saveConfig)
        self.t3EditConfigBtn.clicked.connect(self.t3_editConfig)

        self.t3EditConfigBtn.setEnabled(False)


        # self.tabWidget.addTab(self.tab_3, "")
        self.innerWorkTabWidget.addTab(self.tab_3, "")

        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1064, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        

        self.retranslateUi(MainWindow)
        # Set default tab
        self.tabWidget.setCurrentIndex(1)
        self.innerWorkTabWidget.setCurrentIndex(1)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "TIKTOK"))
        self.addAccountButton.setText(_translate("MainWindow", "Thêm tài khoản"))
        self.addProxyButton.setText(_translate("MainWindow", "Thêm proxy"))
        self.categoryOptions.setText(_translate("MainWindow", "..."))

        self.saveProfiles.setText(_translate("MainWindow", "Tạo profile"))
        self.interactTiktok.setText(_translate("MainWindow", "Tương tác"))

        # new 6/1
        self.AddCategory.setText(_translate("MainWindow", "Add category"))
        self.RemoveCategory.setText(_translate("MainWindow", "Remove category"))


        item = self.tableWidget.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow", "Username"))
        item = self.tableWidget.horizontalHeaderItem(1)
        item.setText(_translate("MainWindow", "Password"))
        item = self.tableWidget.horizontalHeaderItem(2)
        item.setText(_translate("MainWindow", "Email"))
        item = self.tableWidget.horizontalHeaderItem(3)
        item.setText(_translate("MainWindow", "Email_password"))
        item = self.tableWidget.horizontalHeaderItem(4)
        item.setText(_translate("MainWindow", "Cookie"))
        item = self.tableWidget.horizontalHeaderItem(5)
        item.setText(_translate("MainWindow", "Token"))
        item = self.tableWidget.horizontalHeaderItem(6)
        item.setText(_translate("MainWindow", "Profile Status"))


        item = self.tableWidget.horizontalHeaderItem(7)
        item.setText(_translate("MainWindow", "Proxy"))
        item = self.tableWidget.horizontalHeaderItem(8)
        item.setText(_translate("MainWindow", "Received Jobs"))
        item = self.tableWidget.horizontalHeaderItem(9)
        item.setText(_translate("MainWindow", "Status"))

        __sortingEnabled = self.tableWidget.isSortingEnabled()
        self.tableWidget.setSortingEnabled(False)

        self.filterLabel.setText(_translate("MainWindow", "Lọc:"))

        # NEW
        self.totalSelectedRows.setText(_translate("MainWindow", f"(*) Selected accounts: {self.selected_rows_count}"))
        self.totalRunningRows.setText(_translate("MainWindow", f"Running accounts: {self.running_threads}"))
        self.totalWaitingRows.setText(_translate("MainWindow", f"Waiting accounts: {self.waiting_threads}"))
        self.totalCompletedRows.setText(_translate("MainWindow", f"Completed accounts: {self.completed_threads}"))

        self.tableWidget.itemSelectionChanged.connect(self.updateSelectedRows)

        self.accounts['All category'] = []

        self.widget.hide()

        # NEW 12.1.2024
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.actionTab), _translate("MainWindow", "Quản lý"))

        # NEW
        # Load defaut data when startup
        self.load_default_data()

        # RESTRANLATE FOR TAB CONFIG
        self.livestreamLabel.setText(_translate("MainWindow", "Livestream (nguồn):"))
        self.reLivestreamLabel.setText(_translate("MainWindow", "Livestream (reup):"))
        self.delayTimeLabel.setText(_translate("MainWindow", "Time (delay):"))
        item = self.commentTable.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow", "Comment"))
        item = self.commentTable.horizontalHeaderItem(1)
        item.setText(_translate("MainWindow", "Retrieved At"))
        item = self.commentTable.horizontalHeaderItem(2)
        item.setText(_translate("MainWindow", "Status"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.innerWorkTabWidget), _translate("MainWindow", "Công việc"))
        self.innerWorkTabWidget.setTabText(self.innerWorkTabWidget.indexOf(self.jobConfiguration), _translate("MainWindow", "Bình luận"))
        self.innerWorkTabWidget.setTabText(self.innerWorkTabWidget.indexOf(self.tab_3), _translate("MainWindow", "Thả tim"))

        # TAB 3 - INTERACTIONS
        self.t3LiveSrcLabel.setText(_translate("MainWindow", "Livestream (nguồn):"))
        self.t3WorkTimeLabel.setText(_translate("MainWindow", "Work time (phút):"))
        self.t3LiveStatusLabel.setText(_translate("MainWindow", "Trạng thái: chưa kết nối tới Livestream nào"))
        self.t3WorkTimelineEdit.setValidator(QIntValidator(1, 60))
        self.t3LiveStatusLineEdit.setText("Chưa kết nối!")
        self.t3SaveConfigBtn.setText(_translate("MainWindow", "Lưu"))
        self.t3EditConfigBtn.setText(_translate("MainWindow", "Chỉnh sửa"))
        # self.t3_filterLabel.setText(_translate("MainWindow", "Lọc:"))
        self.t3_connectedDevicesLabel.setText(_translate("MainWindow", "Connected devices:"))
        self.t3_reloadDevicesBtn.setText(_translate("MainWindow", "Reload"))
        self.t3_cloneAccountBtn.setText(_translate("MainWindow", "Thêm tài khoản"))
        self.t3_configureDeviceBtn.setText(_translate("MainWindow", "Thiết lập devices"))

        # item = self.t3tableWidget.horizontalHeaderItem(0)
        # item.setText(_translate("MainWindow", "Account"))
        # item = self.t3tableWidget.horizontalHeaderItem(1)
        # item.setText(_translate("MainWindow", "Started time"))
        # item = self.t3tableWidget.horizontalHeaderItem(2)
        # item.setText(_translate("MainWindow", "Interaction quantity"))
        # item = self.t3tableWidget.horizontalHeaderItem(3)
        # item.setText(_translate("MainWindow", "Status"))
        # item_temp = self.t3tableWidget.horizontalHeaderItem(4)
        # item_temp.setText(_translate("MainWindow", "Actions"))

        item = self.t3tableWidget.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow", "Account"))
        item = self.t3tableWidget.horizontalHeaderItem(1)
        item.setText(_translate("MainWindow", "Device ID"))
        item = self.t3tableWidget.horizontalHeaderItem(2)
        item.setText(_translate("MainWindow", "App order"))
        item = self.t3tableWidget.horizontalHeaderItem(3)
        item.setText(_translate("MainWindow", "Started time"))
        item = self.t3tableWidget.horizontalHeaderItem(4)
        item.setText(_translate("MainWindow", "Interaction quantity"))
        item = self.t3tableWidget.horizontalHeaderItem(5)
        item.setText(_translate("MainWindow", "Status"))
        item_temp = self.t3tableWidget.horizontalHeaderItem(6)
        item_temp.setText(_translate("MainWindow", "Actions"))



        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_3), _translate("MainWindow", "Tương tác"))

        self.t3_connectedDevicesLineEdit.setText(str(len(self.phone_devices)))


    def open_dialog(self):
        dialog = QDialog()
        # Create layout
        layout = QVBoxLayout(self.actionTab)

        # Create buttons
        button1 = QPushButton('Use Cookie', self.actionTab)
        button1.clicked.connect(self.save_profile_by_cookie)

        button2 = QPushButton('Use Profile', self.actionTab)
        button2.clicked.connect(self.save_profile_by_credentials)

        # Add buttons to layout
        layout.addWidget(button1)
        layout.addWidget(button2)

        dialog.setLayout(layout)

        button_pos = self.saveProfiles.pos()

        # Adjust the position of the dialog
        dialog.move(button_pos.x() + 145, button_pos.y() + 115)

        dialog.exec_()

    def save_profile_by_cookie(self):
        print('Save profile by cookie...')

    def save_profile_by_credentials(self):
        print('Save profile by user-pass...')

    def show_error_dialog(self, err_msg):
        # Create an error message box
        error_dialog = QMessageBox(self.actionTab)
        error_dialog.setIcon(QMessageBox.Critical)
        error_dialog.setWindowTitle('Error')
        error_dialog.setText(err_msg)
        error_dialog.setStandardButtons(QMessageBox.Ok)

        # Show the error dialog
        error_dialog.exec_()



    def updateSelectedRows(self):
        # Get the list of selected rows
        self.selected_rows = set()
        for item in self.tableWidget.selectionModel().selectedRows():
            self.selected_rows.add(item.row())

        # Update the label with the total number of selected rows
        self.selected_rows_count = len(self.selected_rows)
        self.totalSelectedRows.setText(f'(*) Selected accounts: {len(self.selected_rows)}')


    def save_profiles(self):
        current_category = self.category.currentText()
        username_keys  = list(self.accounts[current_category].keys())

        # Get selected items
        selected_rows = set(index.row() for index in self.tableWidget.selectionModel().selectedRows())
        selected_rows = list(selected_rows)

        

        if len(selected_rows) == 0:
            self.show_error_dialog(err_msg='Chưa có tài khoản nào được chọn!')
        elif self.accounts[current_category][username_keys[0]]['proxy'] == '':
            self.show_error_dialog(err_msg='Proxy chưa được thêm vào!!')
        else:

            # Display the selected indices
            for row_i in selected_rows:

                tiktok_login_credential = {
                    "username": self.accounts[current_category][username_keys[row_i]]["username"],
                    "password": self.accounts[current_category][username_keys[row_i]]["password"],
                }

                proxy = self.split_proxies(self.accounts[current_category][username_keys[row_i]]['proxy'])

                tiktok_worker = SeleniumWorker(
                                                facebook_login_credential={},
                                                tiktok_login_credential=tiktok_login_credential,
                                                cookie_str="",
                                                proxy=proxy, profile_id=self.accounts[current_category][username_keys[row_i]]['username'],
                                                tasks=['generate_profile']
                                                )

                '''
                1/1/2024 -
                Connect signals.started and signals.finished 
                to the thread_start and thread_finished functions 
                to update the running_threads, waiting_threads 
                and completed_threads counters
                '''
                tiktok_worker.signals.started.connect(self.thread_started)
                tiktok_worker.signals.finished.connect(self.thread_finished)
                
                tiktok_worker.signals.result.connect(lambda result, row=row_i: self.display_result(result, row))
                tiktok_worker.signals.error.connect(lambda error, row=row_i: self.display_error(error, row))
                tiktok_worker.signals.profile_status.connect(lambda status, row=row_i: self.change_profile_status(status, row))
                tiktok_worker.signals.cookie.connect(lambda cookie, row=row_i: self.change_cookie(cookie, row))

                # Execute the worker in the thread pool 2 (used for workers only)
                self.threadpool_2.start(tiktok_worker)

            
    def thread_started(self):
        self.running_threads += 1
        self.update_labels()

    def thread_finished(self):
        self.running_threads -= 1
        self.completed_threads += 1
        self.update_labels()        

    def update_labels(self):
        running_threads = self.running_threads
        waiting_threads = self.selected_rows_count - (self.running_threads + self.completed_threads)
        completed_threads = self.completed_threads

        self.totalRunningRows.setText(f"Running accounts: {running_threads}")
        self.totalWaitingRows.setText(f"Waiting accounts: {waiting_threads}")
        self.totalCompletedRows.setText(f"Completed accounts: {completed_threads}")

            
    def showContextMenu(self, pos):
        selected_rows = set(index.row() for index in self.tableWidget.selectionModel().selectedRows())

        def create_action(from_cate, to_cate):
            return partial(self.remove_account, selected_rows, from_cate, to_cate)

        if len(selected_rows) > 0:
            # Convert the widget coordinates to global coordinates
            global_pos = self.tableWidget.mapToGlobal(pos)

            # Create a context menu
            context_menu = QMenu(self.tableWidget)

            # Add title action (disabled and with a different font)
            title_action = context_menu.addAction("Actions:")
            title_action.setEnabled(False)
            title_font = title_action.font()
            title_font.setBold(True)
            title_action.setFont(title_font)
            title_action.setEnabled(False)

            # Add actions to the context menu
            # action_save_profile = QAction("Test profile", self.tableWidget)

            # Connect actions to slots (you can implement your own slots)
            # action_save_profile.triggered.connect(lambda: self.test_profile(selected_rows))


            # Creating a submenu under the "File" menu
            removing_account_menu = QMenu('Chuyển category')

            # Adding actions to the submenu
            # remove_account_menu.addAction('1')
            # remove_account_menu.addAction('2')

            if self.category.count() > 0:
                category_arr = [self.category.itemText(i) for i in range(self.category.count())]
                category_arr.pop(0) # remove category "All category" from category list
                for i, item in enumerate(category_arr):
                    if item == self.category.currentText():
                        category_arr.pop(i) # remove current category from category list
                action_dict = {}
                for i in range(len(category_arr)):
                    var_name = f"action_{category_arr[i]}"
                    from_cate = self.category.currentText()
                    to_cate = category_arr[i]
                    action_dict[var_name] = QAction(category_arr[i])
                    action_dict[var_name].triggered.connect(create_action(from_cate, to_cate))
                    removing_account_menu.addAction(action_dict[var_name])





            # Add actions to the context menu
            # context_menu.addAction(action_save_profile)
            context_menu.addMenu(removing_account_menu)

            # Show the context menu at the global position
            context_menu.exec_(global_pos)

            

    

    def remove_account(self, selected_rows, from_cate, to_cate):
        removed_accounts = selected_rows
        confirmed_status = self.show_confirm_dialog(f"Bạn có chắc muốn chuyển {len(removed_accounts)} tài khoản từ '{from_cate}' sang '{to_cate}' hay không?")
        if confirmed_status == 1:
            # print(f"Bạn đã chuyển thành công {len(removed_accounts)} tài khoản từ '{from_cate}' sang '{to_cate}' thành công!")

            

            keys = list(self.accounts[from_cate].keys())

            dict1 = {}
            dict2 = self.accounts[to_cate]
            for row in selected_rows:
                key = keys[row]
                dict1[key] = self.accounts[from_cate][key]
            dup_count = self.count_duplicate_keys(dict1, dict2)

            if dup_count > 0: # There are duplicate elements
                overwrite_confirm = self.show_confirm_dialog(question_text=f"Phát hiện {dup_count} tài khoản bị trùng lặp, bạn có muốn ghi đè?")
                # If confirm is 1 then overwrite destination category
                if overwrite_confirm == 1:
                    for row in selected_rows:
                        key = keys[row]
                        popped_account = self.accounts[from_cate].pop(key)
                        popped_account["category"] = to_cate
                        self.accounts[to_cate][key] = popped_account
                
                    
                elif overwrite_confirm == 0: #Write only new items to destination category
                    for row in selected_rows:
                        key = keys[row]
                        if key not in list(dict2.keys()): # Implement only item with key do not exists in destination dict (category)
                            popped_account = self.accounts[from_cate].pop(key)
                            popped_account["category"] = to_cate
                            self.accounts[to_cate][key] = popped_account

                # UPDATE THE DEFAULT JSON DATA FILE AND THE TABLE DATA
                self.add_accounts_to_table(self.accounts)
                self.category.setCurrentText(to_cate)
                self.saveJsonFile(self.accounts)

            elif dup_count == 0: # There is no duplicate element
                for row in selected_rows:
                    key = keys[row]
                    # print(self.accounts[from_cate][key])
                    popped_account = self.accounts[from_cate].pop(key)
                    popped_account["category"] = to_cate
                    self.accounts[to_cate][key] = popped_account
                
                self.add_accounts_to_table(self.accounts)
                self.category.setCurrentText(to_cate)
                self.saveJsonFile(self.accounts)
        elif confirmed_status == 0:
            print(f"You have confirmed no!")
            
    def count_duplicate_keys(self, dict1, dict2):
        # Get the sets of keys from both dictionaries
        keys_set1 = set(dict1.keys())
        keys_set2 = set(dict2.keys())

        # Find the common keys (intersection) between the two sets
        common_keys = keys_set1.intersection(keys_set2)

        # Count the number of common keys
        count = len(common_keys)

        return count


    def test_profile(self, selected_rows):

        current_category = self.category.currentText()

        row_index = list(selected_rows)[0]
        try:
            if self.accounts[current_category][row_index]['profile_status'] == False:
                return self.show_error_dialog(err_msg='Tài khoản này không tồn tại profile để test!')


            if len(self.accounts[current_category][row_index]['proxy']) == 0:
                return self.show_error_dialog(err_msg='Cần thêm proxy để test profile!')

            proxy = self.split_proxies(self.accounts[current_category][row_index]['proxy'])

            profile_id = self.accounts[current_category][row_index]['uid']

            cookie = self.accounts[current_category][row_index]['cookie']

            facebook_login_credential = {
                    "uid": self.accounts[current_category][row_index]["uid"],
                    "password": self.accounts[current_category][row_index]["password"],
                    "fa_secret": self.accounts[current_category][row_index]["fa_secret"],
                }


            facebook_worker = SeleniumWorker(
                                            facebook_login_credential=facebook_login_credential,
                                            cookie_str=cookie,
                                            proxy=proxy, profile_id=profile_id,
                                            tasks=['test_profile']
                                            )

            facebook_worker.signals.started.connect(self.thread_started)
            facebook_worker.signals.finished.connect(self.thread_finished)
            
            facebook_worker.signals.result.connect(lambda result, row=row_index: self.display_result(result, row))
            facebook_worker.signals.error.connect(lambda error, row=row_index: self.display_error(error, row))
            facebook_worker.signals.profile_status.connect(lambda status, row=row_index: self.change_profile_status(status, row))
            facebook_worker.signals.cookie.connect(lambda cookie, row=row_index: self.change_cookie(cookie, row))

            # Execute the worker in the thread pool
            self.threadpool_2.start(facebook_worker)

        except Exception as error:
            tb_info = traceback.format_exc()
            print('Có lỗi xảy ra khi test profile:', error, tb_info)

    def on_run_button_clicked(self, row, col):
        current_category = self.category.currentText()

        if len(self.accounts[current_category][row]['proxy']) == 0:
            self.changeCellValue(row=row, col=self.column_order.index('status'), newValue='Lỗi xảy ra: Hãy thêm proxies trước!')
        else:
            # _______________USE SELENIUM-FACEBOOK-WORKER_________________
            facebook_login_credential = {
                "uid": self.accounts[current_category][row]["face_uid"],
                "password": self.accounts[current_category][row]["face_pass"],
                "fa_secret": self.accounts[current_category][row]["face_secret"],
            }

            tds_login_credential = {
                'username': self.accounts[current_category][row]['tds_username'],
                'password': self.accounts[current_category][row]['tds_pass']
            }

            proxy = self.split_proxies(self.accounts[current_category][row]['proxy'])

            facebook_worker = SeleniumWorker(facebook_login_credential=facebook_login_credential,
                                            tds_login_credential=tds_login_credential,
                                            proxy=proxy
                                            )
            facebook_worker.signals.result.connect(lambda result: self.display_result(result, row))
            facebook_worker.signals.error.connect(lambda error: self.display_error(error, row))
            # Execute the worker in the thread pool
            self.threadpool_2.start(facebook_worker)
    
    def display_result(self, result, row):
        print('result:', result)
        print('row:', row)
        self.changeCellValue(row, self.column_order.index('status'), newValue=str(result))

    def display_error(self, error, row):
        print('error:', error)
        self.changeCellValue(row, self.column_order.index('status'), newValue=f'{error}')

    def change_profile_status(self, status, row):
        current_category = self.category.currentText()
      
        self.changeCellValue(row, self.column_order.index('profile_status'), newValue=status)
        self.accounts[current_category][row]['profile_status'] = True
        


    def change_cookie(self, cookie, row):
        current_category = self.category.currentText()

        self.changeCellValue(row, self.column_order.index('cookie'), newValue=f'{cookie}')
        # change the account's cookie
        self.accounts[current_category][row]['cookie'] = cookie

    def changeCellValue(self, row, col, newValue):
        current_category = self.category.currentText()
        # newValue == 0 or 1 is corresponding change profile_status column
        if newValue == 0:
            new_item = QtWidgets.QLabel()
            pixmap = QPixmap(self.x_mark_img)
            new_item.setPixmap(pixmap)
            new_item.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
            self.tableWidget.setCellWidget(row, col, new_item)

            self.accounts[current_category][row]['profile_status'] = False
        elif newValue == 1:
            new_item = QtWidgets.QLabel()
            pixmap = QPixmap(self.check_mark_img)
            new_item.setPixmap(pixmap)
            new_item.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
            self.tableWidget.setCellWidget(row, col, new_item)
        else:
            # Create a new item with the desired value
            new_item = QtWidgets.QTableWidgetItem(newValue)

            # Set the new item for the specified cell
            self.tableWidget.setItem(row, col, new_item)

    def changeWorkerCellTableValue(self, row, col, newValue):
            new_item = QtWidgets.QTableWidgetItem(newValue)

            # Set the new item for the specified cell
            self.t3tableWidget.setItem(row, col, new_item)


    def add_row(self, row_index, data):
        _translate = QtCore.QCoreApplication.translate
        for column_index, key in enumerate(self.column_order):

            value = data.get(key, "")
            
            item = QtWidgets.QTableWidgetItem()
            item.setText(_translate("MainWindow", str(value)))
            self.tableWidget.setItem(row_index, column_index, item)


            


    def add_accounts_to_table(self, accounts: dict):
        self.tableWidget.setRowCount(len(accounts))
        __sortingEnabled = self.tableWidget.isSortingEnabled()

        # Positions of field columns in the data table
        # column_order = ["tds_username", "tds_pass", "face_uid", "face_pass", "cookie", "token", "proxy", "user_agent", "tds_coins",  "status",  "action"]

        for row_index, account_data in enumerate(accounts.values()):
            self.add_row(row_index, account_data)


        self.tableWidget.setSortingEnabled(__sortingEnabled)

        password_delegate = PasswordDelegate()

        # Set format (*) for columns 'password' and 'email_password' 
        self.tableWidget.setItemDelegateForColumn(self.column_order.index('password'), password_delegate)
        self.tableWidget.setItemDelegateForColumn(self.column_order.index('email_password'), password_delegate)    

        print('Added accounts successfully!')
    
    def add_accounts_to_worker_table(self, accounts: dict):
        self.t3tableWidget.setRowCount(len(accounts))
        __sortingEnabled = self.tableWidget.isSortingEnabled()

        # Positions of field columns in the data table
        # column_order = ["tds_username", "tds_pass", "face_uid", "face_pass", "cookie", "token", "proxy", "user_agent", "tds_coins",  "status",  "action"]

        for row_index, account_data in enumerate(accounts.values()):
            self.add_row_to_worker_table(row_index, account_data)

        self.t3tableWidget.setSortingEnabled(__sortingEnabled)

    def add_row_to_worker_table(self, row_index, data):
        _translate = QtCore.QCoreApplication.translate
        for column_index, key in enumerate(self.worker_column_order):
            value = data.get(key, "")
            item = QtWidgets.QTableWidgetItem()
            item.setText(_translate("MainWindow", str(value)))
            self.t3tableWidget.setItem(row_index, column_index, item)

            if key == "actions":
                button = QPushButton("Start")
                button.clicked.connect(lambda: self.start_adb_worker(row_index))
                item = QtWidgets.QTableWidgetItem()
                self.t3tableWidget.setCellWidget(row_index, column_index, button)


    def add_row_to_temp_clone_table(self, row_index, data):
        _translate = QtCore.QCoreApplication.translate
        for column_index, key in enumerate(self.column_order):

            value = data.get(key, "")
            
            item = QtWidgets.QTableWidgetItem()
            item.setText(_translate("MainWindow", str(value)))
            self.tempCloneTableWidget_2.setItem(row_index, column_index, item)

    def add_row_to_device_table(self, row_index, data):
        _translate = QtCore.QCoreApplication.translate
        for column_index, key in enumerate(self.device_column_order):

            value = data.get(key, "")
            
            item = QtWidgets.QTableWidgetItem()
            item.setText(_translate("MainWindow", str(value)))
            self.deviceTable.setItem(row_index, column_index, item)

    def add_accounts_to_temp_table(self, accounts: list):
        self.tempTableWidget.setRowCount(len(accounts))
        __sortingEnabled = self.tableWidget.isSortingEnabled()

        for row_index, account_data in enumerate(accounts):
            self.add_row_to_temp_table(row_index, account_data)
        self.tempTableWidget.setSortingEnabled(__sortingEnabled)

        print('Added accounts to the temporary table!')

    def add_row_to_temp_table(self, row_index, data):
        for column_index, cell in enumerate(data):
            item = QtWidgets.QTableWidgetItem(cell)
            self.tempTableWidget.setItem(row_index, column_index, item)

    def add_accounts_from_file(self):
        try:
            # Open file Dialog
            file_name, _ = QFileDialog.getOpenFileName(None, "Open File", "", "All Files (*);;Text Files (*.txt);;JSON Files (*.json)")
            
            # Read file and import to data table
            if file_name:

                file = QFile(file_name)

                # Check the file extension
                file_extension = os.path.splitext(file_name)[1]

                if file_extension == '.txt':
                    if file.open(QFile.ReadOnly | QFile.Text):
                        stream = QTextStream(file)
                        facebook_accounts_content = stream.readAll()
                        # remove first and last space
                        facebook_accounts_content = facebook_accounts_content.strip()

                        account_lines = facebook_accounts_content.split('\n')

                        self.accounts = self.file_preprocessing(account_lines)

                        # Add data to the data table
                        self.add_accounts_to_table(self.accounts)
                        
                        file.close()
                    else:
                        print(f"Error opening file: {file.errorString()}")

                if file_extension == '.json':
                    if file.open(QFile.ReadOnly | QFile.Text):
                        stream = QTextStream(file)
                        fa_accounts_content = stream.readAll()

                        # Parse JSON data using QJsonDocument
                        document = QJsonDocument.fromJson(fa_accounts_content.encode('utf-8'))

                        # Convert QJsonDocument to Python dictionary
                        fa_accounts_dict : dict = json.loads(document.toJson(QJsonDocument.Compact).data().decode('utf-8'))

                        self.accounts = list(fa_accounts_dict.values())

                        # Add data to the data table
                        self.add_accounts_to_table(self.accounts)
                        
                        file.close()

            print('accounts:', self.accounts)

        except Exception as error:
            print(error)

    def file_preprocessing(self, account_lines, account_pos: list) -> None:
        current_category = self.category.currentText()
        accounts_arr = []
        accounts_obj = {}
        account_wrapper_obj = {}
        for index, account_line in enumerate(account_lines):



            account_values = account_line.split('|')

            account_obj = {}
            for item in account_pos:
                account_obj[item[1]] = account_values[item[0]]

            account_obj['category'] = current_category
            

            # account_obj = {
            #     "uid": account_values[0], 
            #     "password": account_values[1],
            #     "fa_secret": account_values[2],
            #     "cookie": account_values[5],
            #     "token": account_values[6],
            #     "email": account_values[3],
            #     "email_password": account_values[4],
            #     "proxy": '',
            #     "status": ''
            #     }
            
            # accounts_arr.append(account_obj)
            accounts_obj[account_obj["username"]] = account_obj

        # self.accounts[current_category] = accounts_arr
        self.accounts[current_category] = accounts_obj
        return None

    def split_proxies(self, proxy_string:str)->dict:
        host, port, username, password = proxy_string.split(':')

        return {'host': host, 'port': port, 'username': username, 'password': password}
    
    def add_proxies_from_file(self):
        try:
            if self.tableWidget.rowCount() == 0:
                self.show_error_dialog(err_msg="Bạn phải thêm accounts trước!")
            else:
                # Open file Dialog
                file_name, _ = QFileDialog.getOpenFileName(None, "Open File", "", "All Files (*);;Text Files (*.txt)")
                    
                # Read file and import to data table
                if file_name:

                    file = QFile(file_name)

                    if file.open(QFile.ReadOnly | QFile.Text):
                        stream = QTextStream(file)
                        proxies_content = stream.readAll()
                        # remove first and last space
                        proxies_content = proxies_content.strip()

                        proxies_lines = proxies_content.split('\n')

                        # Add proxies to accounts
                        
                        count = 0
                        for account in self.accounts:
                            if count > len(proxies_lines) - 1:
                                # reset count to 0
                                count = 0

                            account["proxy"] = proxies_lines[count]
                            
                            # increase count
                            count += 1

                            
                        self.add_accounts_to_table(self.accounts)             

                        file.close()

                        print("Added proxies to accounts successfully!")
                    else:
                        print(f"Error opening file: {file.errorString()}")
        except Exception as error:
            print(error)

    def update_config_days(self, config_json):
        i = 0

        for key in config_json.keys():
            self.configDays.setItemText(i, key)
            i+=1
        
        
    def check_profiles_exists(self, profile_path):
        profile_path = Path(profile_path)

        if profile_path.exists() and profile_path.is_dir():
            return True
        
        return False
    

    def interact_tiktok(self):
        # selected_config_day = self.configDays.currentText()


        # if len(selected_config_day) == 0:
            # self.show_error_dialog(err_msg="You have not added the config yet!")
        # else:
            # print('config_day:', selected_config_day)
        
        if self.tableWidget.rowCount() == 0:
            return self.show_error_dialog(err_msg="Chưa có tài khoản nào được chọn!")
            
        
        return

    
    def convert_data_to_dict(self):
        accounts_arr = self.accounts
        accounts_dict = {}

        for item in accounts_arr:
            key = item['username']

            # remove item with key = status if it exist
            if item.get('status') is not None:
                item.pop('status')

            accounts_dict[key] = item

            

        return accounts_dict
    
    def exportToJson(self):

        if len(self.accounts) == 0:
            return self.show_error_dialog(err_msg="Chưa có dữ liệu nào để xuất file!")

        file_name, _ = QFileDialog.getSaveFileName(None, "Save JSON File", "", "JSON Files (*.json)")

        if file_name:
            accounts = self.convert_data_to_dict()

            with open(file_name, 'w') as json_file:
                json.dump(accounts, json_file, indent=4)
            print(f"Data exported to {file_name}")

    def show_add_accounts_dialog(self):
        # Create a dialog
        self.dialog = QDialog()
        self.dialog.setWindowTitle('Thêm tài khoản')
        self.dialog.setGeometry(450, 180, 1000, 390)  # Set the size of the dialog

        # Create a text edit box
        text_edit = QTextEdit(self.dialog)
        # text_edit.setGeometry(10, 10, 900, 360)

        temp_columns = ["","username", "password", "email", "email_password", "cookie", "token", ]

        self.comboBoxA = QtWidgets.QComboBox(self.dialog)
        self.comboBoxA.setObjectName("comboBoxA")
        self.comboBoxA.addItems(temp_columns)


        self.comboBoxB = QtWidgets.QComboBox(self.dialog)
        self.comboBoxB.setObjectName("comboBoxB")
        self.comboBoxB.addItems(temp_columns)

        self.comboBoxC = QtWidgets.QComboBox(self.dialog)
        self.comboBoxC.setObjectName("comboBoxC")
        self.comboBoxC.addItems(temp_columns)

        self.comboBoxD = QtWidgets.QComboBox(self.dialog)
        self.comboBoxD.setObjectName("comboBoxD")
        self.comboBoxD.addItems(temp_columns)

        self.comboBoxE = QtWidgets.QComboBox(self.dialog)
        self.comboBoxE.setObjectName("comboBoxE")
        self.comboBoxE.addItems(temp_columns)

        self.comboBoxF = QtWidgets.QComboBox(self.dialog)
        self.comboBoxF.setObjectName("comboBoxF")
        self.comboBoxF.addItems(temp_columns)

        self.comboBoxG = QtWidgets.QComboBox(self.dialog)
        self.comboBoxG.setObjectName("comboBoxG")
        self.comboBoxG.addItems(temp_columns)

        self.comboBoxGroup = [self.comboBoxA, self.comboBoxB, self.comboBoxC, self.comboBoxD]



        # The Temporary Table Widget
        self.tempTableWidget = QtWidgets.QTableWidget()
        self.tempTableWidget.setGeometry(QtCore.QRect(180, 130, 411, 192))
        self.tempTableWidget.setObjectName("tableWidget")
        self.tempTableWidget.setColumnCount(6)
        self.tempTableWidget.setRowCount(5)


        item = QtWidgets.QTableWidgetItem()
        self.tempTableWidget.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tempTableWidget.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tempTableWidget.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.tempTableWidget.setHorizontalHeaderItem(3, item)
        item = QtWidgets.QTableWidgetItem()
        self.tempTableWidget.setHorizontalHeaderItem(4, item)
        item = QtWidgets.QTableWidgetItem()
        self.tempTableWidget.setHorizontalHeaderItem(5, item)
        item = QtWidgets.QTableWidgetItem()
        self.tempTableWidget.setHorizontalHeaderItem(6, item)

        # _translate = QtCore.QCoreApplication.translate
        # item = self.tempTableWidget.verticalHeaderItem(0)
        # item.setText(_translate("MainWindow", "1"))
        # item = self.tempTableWidget.verticalHeaderItem(1)
        # item.setText(_translate("MainWindow", "2"))

        column_widths = [136, 136, 136, 136, 136, 136, 136]
        for i, width in enumerate(column_widths):
            self.tempTableWidget.setColumnWidth(i, width)

        # Caught the text-change's event on text_edit
        text_edit.textChanged.connect(lambda: self.onAccountsTextChanged(text_edit.toPlainText()))

        # Add Save button to close the dialog
        save_button = QPushButton('Lưu', self.dialog)
        save_button.clicked.connect(lambda: self.onSaveAddAccountsClicked(text_edit.toPlainText()))

        # Set up the layout
        self.dialog_layout = QGridLayout()
        self.dialog_layout.addWidget(text_edit, 0, 0, 1, 7)
        self.dialog_layout.addWidget(self.comboBoxA, 1, 0)
        self.dialog_layout.addWidget(self.comboBoxB, 1, 1)
        self.dialog_layout.addWidget(self.comboBoxC, 1, 2)
        self.dialog_layout.addWidget(self.comboBoxD, 1, 3)
        self.dialog_layout.addWidget(self.comboBoxE, 1, 4)
        self.dialog_layout.addWidget(self.comboBoxF, 1, 5)
        self.dialog_layout.addWidget(self.comboBoxG, 1, 6)
        self.dialog_layout.addWidget(self.tempTableWidget, 2, 0, 1, 7)
        self.dialog_layout.addWidget(save_button, 3, 0, 1, 2)

        self.dialog.setLayout(self.dialog_layout)

        # Show the dialog
        self.dialog.exec_()

    def onSaveAddAccountsClicked(self, text):
        current_category = self.category.currentText()

        account_lines = text.splitlines()

        # account_pos used for get columns position from temporary table
        account_pos = []
        for index, combo_box in enumerate(self.comboBoxGroup):
            account_pos.append((index, combo_box.currentText()))

        exist_username = False
        for item in account_pos:
            if item[1] == 'username':
                exist_username = True

        print('account_pos', account_pos)
    
        if not exist_username:
            return self.show_error_dialog(err_msg="Phải chọn ít nhất 1 cột có Username!")
        
        self.file_preprocessing(account_lines, account_pos) #add more account to self.accounts by "key-value pairs"

        # Add data to the data table
        self.add_accounts_to_table(self.accounts[current_category])

        # Automate save deufalt json file
        self.saveJsonFile(self.accounts)

        self.dialog.close()

    def saveJsonFile(self, json_data):
        file_path = "./defaults/data.json"
        try:
            # Write the JSON data to the selected file
            json_object = json.dumps(json_data, indent=4)
            with open(file_path, 'w') as file:
                file.write(json_object)

            print(f'Successfully saved JSON file: {file_path}')
        except Exception as e:
            print(f'Error saving JSON file: {e}')

    def saveClonedJsonFile(self, json_data):
        file_path = "./defaults/cloned_data.json"
        try:
            # Write the JSON data to the selected file
            json_object = json.dumps(json_data, indent=4)
            with open(file_path, 'w') as file:
                file.write(json_object)

            print(f'Successfully saved JSON file: {file_path}')
        except Exception as e:
            print(f'Error saving JSON file: {e}')

    def show_add_proxies_dialog(self):
        if self.tableWidget.rowCount() == 0:
            return self.show_error_dialog(err_msg="Bạn phải thêm tài khoản trước khi thêm proxy")

        # Create a dialog
        self.dialog = QDialog()
        self.dialog.setWindowTitle('Thêm proxy')
        self.dialog.setGeometry(450, 180, 1000, 390)  # Set the size of the dialog

        # Create a text edit box
        text_edit = QTextEdit(self.dialog)
        text_edit.setGeometry(10, 10, 900, 360)

        # Add Save button to close the dialog
        save_button = QPushButton('Lưu', self.dialog)
        save_button.clicked.connect(lambda: self.onSaveAddProxiesClicked(text_edit.toPlainText()))

        # Set up the layout
        dialog_layout = QVBoxLayout()
        dialog_layout.addWidget(text_edit)
        dialog_layout.addWidget(save_button)

        self.dialog.setLayout(dialog_layout)

        # Show the dialog
        self.dialog.exec_()

    def onSaveAddProxiesClicked(self, text):
        current_category = self.category.currentText()
        if current_category == "All category":

            all_accounts = self.get_all_accounts()

            proxy_lines = text.splitlines()
            print('proxy_lines', proxy_lines)
            print('len', len(proxy_lines))


            if len(proxy_lines) != 0:
                count = 0
                for account in all_accounts.values():
                    if count > len(proxy_lines) - 1:
                        # reset count to 0
                        count = 0


                    account["proxy"] = proxy_lines[count]

                    # update self.accounts with proxy line
                    belonged_category = account["category"]
                    username = account["username"]
                    self.accounts[belonged_category][username]["proxy"] = proxy_lines[count]
                    
                    # increase count
                    count += 1

                    
                self.add_accounts_to_table(all_accounts)             

                print("Added proxies to accounts successfully!")

                self.saveJsonFile(self.accounts)
            
            
            self.dialog.close()

    def toggle_category_options(self):
        if self.widget.isHidden():
            self.widget.show()
        else:
            self.widget.hide()

    def show_add_new_category(self):
        self.widget.hide()
        dialog = AddCategoryDialog()
        result = dialog.exec_()

        if result == QDialog.Accepted:
            category_input_text = dialog.text_input.text()
            

            # Check if the item already exists in the QComboBox
            checked_index = self.category.findText(category_input_text)

            if checked_index != -1: # Item existed
                return self.show_error_dialog(err_msg=f"Category: '{category_input_text}' đã tồn tại!")


            self.category.addItem(category_input_text)

            # add new category as a key to self.accounts: dict
            self.accounts[category_input_text] = {}

            self.category.setCurrentText(category_input_text)

            print(f'new category: {category_input_text}')

            print(self.accounts)

    
    def show_confirm_dialog(self, question_text: str) -> int:
        # self.widget.hide()
        confirmation = QMessageBox.question(None, 'Confirmation', question_text, QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

        if confirmation == QMessageBox.Yes:
            return 1
        else:
            return 0

    def show_confirm_remove_category(self):
        self.widget.hide()
        confirmation = QMessageBox.question(None, 'Confirmation', 'Bạn có chắc chắn muốn xóa?', QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

        if confirmation == QMessageBox.Yes:
            print('You clicked Yes!')
            self.removeCurrentCategory()
        else:
            print('You clicked No.')
  
    def removeCurrentCategory(self):
        # Remove the currently selected item from the QComboBox
        current_index = self.category.currentIndex()
        if current_index != 0:  # Check if an item is selected
            self.category.removeItem(current_index)

    def update_table(self, category):
        if category == "All category":
            all_data = {}
            for account_obj in self.accounts.values():
                all_data.update(account_obj)

            # Show all accounts
            self.add_accounts_to_table(all_data)
            # self.add_accounts_to_worker_table(all_data)
        else:
            # show accounts by category that them belong
            self.add_accounts_to_table(self.accounts[category])
            # self.add_accounts_to_worker_table(self.accounts[category])
    
    


    def load_default_data(self):
        # load default data in the tab manager --------------------------------
        origin_data_path = "./defaults/data.json"

        with open(origin_data_path, 'r') as file:
            data = json.load(file)
        self.accounts = data


        all_data = {}
        for account_obj in self.accounts.values():
            all_data.update(account_obj)

        # Show all accounts
        self.add_accounts_to_table(all_data)
        categories = list(self.accounts.keys())
        for i in range(1, len(categories)):
            self.category.addItem(categories[i])


        # load default data in the tab working -----------------------------------
        cloned_data_path = "./defaults/cloned_data.json"

        with open(cloned_data_path, 'r') as file:
            cloned_data = json.load(file)
        self.cloned_accounts = cloned_data

        # Show all accounts
        self.add_accounts_to_worker_table(self.cloned_accounts)

    def onAccountsTextChanged(self, text):

        account_lines = text.splitlines()
        processed_accounts = []
        for line in account_lines:
            splitted_line = line.split('|')
            processed_accounts.append(splitted_line)

        if len(processed_accounts) > 0:
            self.add_accounts_to_temp_table(processed_accounts)

    def t3_saveConfig(self):
        live_src = self.t3LiveSrclineEdit.text()
        work_time_text = self.t3WorkTimelineEdit.text()
        self.t3LiveSrclineEdit.setEnabled(False)
        self.t3WorkTimelineEdit.setEnabled(False)
        if len(live_src) <= 0:
            return self.show_error_dialog(err_msg='Vui lòng nhập "Livestream (nguồn)".')
        if live_src[0] != "@":
            return self.show_error_dialog(err_msg='"Livestream (nguồn)" không đúng định dạng (@id), hãy thử lại!')
        if len(work_time_text) <= 0:
            return self.show_error_dialog(err_msg='Vui lòng nhập "Work time".')

        self.tiktok_socket_worker = TiktokSocketWorker(live_id=live_src)
        self.tiktok_socket_worker.signals.con_status.connect(self.changeEditConfigStatus)
        self.tiktok_socket_worker.signals.result.connect(self.changeLiveConnectionStatus)
        self.tiktok_socket_worker.signals.error.connect(self.showLiveConnectionError)
        

        # Execute the worker in the thread pool
        self.threadpool_1.start(self.tiktok_socket_worker)

        

    def t3_editConfig(self):
        confirm_status: int = self.show_confirm_dialog(question_text="Chỉnh sửa Config sẽ ngắt kết nối với Livestream hiện tại, bạn có chắc?")
        if confirm_status == 1:
            print('Thread counts before stop:', self.threadpool_1.activeThreadCount())
            self.tiktok_socket_worker.stop()
            time.sleep(5)
            print('Thread counts after stop:', self.threadpool_1.activeThreadCount())
        elif confirm_status == 0:
            print("You confirmed no!") 


    def changeEditConfigStatus(self, live_status):
        if live_status == 1:
            self.t3SaveConfigBtn.setEnabled(False)
            self.t3EditConfigBtn.setEnabled(True)
            self.t3LiveSrclineEdit.setEnabled(False)
            self.t3WorkTimelineEdit.setEnabled(False)
        elif live_status == 0:
            self.t3SaveConfigBtn.setEnabled(True)
            self.t3EditConfigBtn.setEnabled(False)
            self.t3LiveSrclineEdit.setEnabled(True)
            self.t3WorkTimelineEdit.setEnabled(True)

    def changeLiveConnectionStatus(self, msg):
        self.t3LiveStatusLineEdit.setText(msg)
    
    def showLiveConnectionError(self, err_msg):
        print(err_msg)
        # self.show_error_dialog(err_msg=err_msg)

    def get_all_accounts(self):
        all_data = {}
        for account_obj in self.accounts.values():
            all_data.update(account_obj)

        return all_data


    def start_adb_worker(self, row_index):
        if len(self.phone_devices) == 0:
            return self.show_error_dialog(err_msg="Không có thiết bị (phone) nào hiện đang được kết nối!")


        workers = {}
        t3_curr_category = self.t3_category.currentText()
        if t3_curr_category == "All category":
            for account_obj in self.accounts.values():
                workers.update(account_obj)
            keys = list(workers.keys())
            worker_key = keys[row_index]
            this_worker = workers[worker_key]
            # print(this_worker) - {'username': 'huyenthoai592223', 'password': '@K4GGBkMEiKEu', '': '7G9Q6ZHqHk', 'category': '2'}
        else:
            workers = self.accounts[t3_curr_category]
            keys = list(workers.keys())
            worker_key = keys[row_index]
            this_worker = workers[worker_key]
        
        # Temporarily unused this
        if this_worker.get('proxy') is None:
            self.show_error_dialog('Tài khoản này chưa có proxy, hãy thêm vào và thử lại!')
        else:
            print(self.phone_devices)
            for i,device in enumerate(self.phone_devices):
                if device['status'] == "free":
                    chosen_device = self.phone_devices[i]
                    self.phone_devices[i]["status"] = "busy"
                    break

            # threading.Thread(target=start_worker, args=(chosen_device["name"], this_worker)).start()
            # thread_count = len(ADB.get_devices())
            # proxies = []
            # p_count = 0
            # with open('./resources/proxy-101-200.txt') as f:
                # proxies = f.read().split('\n')

            # for i in range(thread_count):
            #     worker_index = i
            #     threading.Thread(target=start_worker, args=(worker_index, proxies[p_count])).start()
            #     p_count += 1


    def t3_ShowDialogCloneAccounts(self):

        _translate = QtCore.QCoreApplication.translate

        # self.innerWorkTabWidget.addTab(self.tab_3, "")
        
        # Create a dialog
        dialog = QDialog()
        dialog.setWindowTitle('Thêm tài khoản')
        dialog.setGeometry(450, 180, 1000, 390)  # Set the size of the dialog

        tabWidget = QtWidgets.QTabWidget(dialog)
        tabWidget.setGeometry(QtCore.QRect(0, 0, 1000, 390))
        tabWidget.setObjectName("tabWidget")

        tab_add_by_pasting = QtWidgets.QWidget()
        tab_add_by_pasting.setObjectName("tab_add_by_pasting")
        tabWidget.addTab(tab_add_by_pasting, "")
        tabWidget.setTabText(tabWidget.indexOf(tab_add_by_pasting), _translate("MainWindow", "Dạng text"))

        tab_add_by_category = QtWidgets.QWidget()
        tab_add_by_category.setObjectName("tab_add_by_pasting")
        tabWidget.addTab(tab_add_by_category, "")
        tabWidget.setTabText(tabWidget.indexOf(tab_add_by_category), _translate("MainWindow", "Chọn từ category"))


        # Create a text edit box
        text_edit = QTextEdit(tab_add_by_pasting)
        # text_edit.setGeometry(10, 10, 900, 360)

        temp_columns = ["","username", "password", "email", "email_password", "cookie", "token", ]

        comboBoxA = QtWidgets.QComboBox(tab_add_by_pasting)
        comboBoxA.setObjectName("comboBoxA")
        comboBoxA.addItems(temp_columns)


        comboBoxB = QtWidgets.QComboBox(tab_add_by_pasting)
        comboBoxB.setObjectName("comboBoxB")
        comboBoxB.addItems(temp_columns)

        comboBoxC = QtWidgets.QComboBox(tab_add_by_pasting)
        comboBoxC.setObjectName("comboBoxC")
        comboBoxC.addItems(temp_columns)

        comboBoxD = QtWidgets.QComboBox(tab_add_by_pasting)
        comboBoxD.setObjectName("comboBoxD")
        comboBoxD.addItems(temp_columns)

        comboBoxE = QtWidgets.QComboBox(tab_add_by_pasting)
        comboBoxE.setObjectName("comboBoxE")
        comboBoxE.addItems(temp_columns)

        comboBoxF = QtWidgets.QComboBox(tab_add_by_pasting)
        comboBoxF.setObjectName("comboBoxF")
        comboBoxF.addItems(temp_columns)

        comboBoxG = QtWidgets.QComboBox(tab_add_by_pasting)
        comboBoxG.setObjectName("comboBoxG")
        comboBoxG.addItems(temp_columns)

        comboBoxGroup = [comboBoxA, comboBoxB, comboBoxC, comboBoxD]



        # The Temporary Table Widget
        tempTableWidget = QtWidgets.QTableWidget()
        tempTableWidget.setGeometry(QtCore.QRect(180, 130, 411, 192))
        tempTableWidget.setObjectName("tempTableWidget")
        tempTableWidget.setColumnCount(7)
        tempTableWidget.setRowCount(5)


        item = QtWidgets.QTableWidgetItem()
        tempTableWidget.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        tempTableWidget.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        tempTableWidget.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        tempTableWidget.setHorizontalHeaderItem(3, item)
        item = QtWidgets.QTableWidgetItem()
        tempTableWidget.setHorizontalHeaderItem(4, item)
        item = QtWidgets.QTableWidgetItem()
        tempTableWidget.setHorizontalHeaderItem(5, item)
        item = QtWidgets.QTableWidgetItem()
        tempTableWidget.setHorizontalHeaderItem(6, item)

        # _translate = QtCore.QCoreApplication.translate
        # item = self.tempTableWidget.verticalHeaderItem(0)
        # item.setText(_translate("MainWindow", "1"))
        # item = self.tempTableWidget.verticalHeaderItem(1)
        # item.setText(_translate("MainWindow", "2"))

        column_widths = [136, 136, 136, 136, 136, 136, 136]
        for i, width in enumerate(column_widths):
            tempTableWidget.setColumnWidth(i, width)

        # Caught the text-change's event on text_edit
        text_edit.textChanged.connect(lambda: self.onAccountsTextChanged(text_edit.toPlainText()))

        # Add Save button to close the dialog
        tab_pasting_save_button = QPushButton('Lưu', tab_add_by_pasting)
        # tab_pasting_save_button.clicked.connect(lambda: self.onSaveAddAccountsClicked(text_edit.toPlainText()))

        # Set up the layout
        layout_1 = QGridLayout()
        layout_1.addWidget(text_edit, 0, 0, 1, 7)
        layout_1.addWidget(comboBoxA, 1, 0)
        layout_1.addWidget(comboBoxB, 1, 1)
        layout_1.addWidget(comboBoxC, 1, 2)
        layout_1.addWidget(comboBoxD, 1, 3)
        layout_1.addWidget(comboBoxE, 1, 4)
        layout_1.addWidget(comboBoxF, 1, 5)
        layout_1.addWidget(comboBoxG, 1, 6)
        layout_1.addWidget(tempTableWidget, 2, 0, 1, 7)
        layout_1.addWidget(tab_pasting_save_button, 3, 0, 1, 2)

        tab_add_by_pasting.setLayout(layout_1)

        #---------------------------------------# For category 2 in dialog add clone accounts ------------------------------------
        temp_category = QtWidgets.QComboBox(tab_add_by_category)
        temp_category.setGeometry(QtCore.QRect(10, 10, 200, 21))
        temp_category.setObjectName("temp_category")
        # temp_category.addItem("All category")

                # The Temporary Table Widget
        self.tempCloneTableWidget_2 = QtWidgets.QTableWidget()
        self.tempCloneTableWidget_2.setGeometry(QtCore.QRect(180, 130, 411, 192))
        self.tempCloneTableWidget_2.setObjectName("tempTableWidget")
        self.tempCloneTableWidget_2.setColumnCount(10)
        self.tempCloneTableWidget_2.setRowCount(39)


        item = QtWidgets.QTableWidgetItem()
        self.tempCloneTableWidget_2.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tempCloneTableWidget_2.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tempCloneTableWidget_2.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.tempCloneTableWidget_2.setHorizontalHeaderItem(3, item)
        item = QtWidgets.QTableWidgetItem()
        self.tempCloneTableWidget_2.setHorizontalHeaderItem(4, item)
        item = QtWidgets.QTableWidgetItem()
        self.tempCloneTableWidget_2.setHorizontalHeaderItem(5, item)
        item = QtWidgets.QTableWidgetItem()
        self.tempCloneTableWidget_2.setHorizontalHeaderItem(6, item)
        item = QtWidgets.QTableWidgetItem()
        self.tempCloneTableWidget_2.setHorizontalHeaderItem(7, item)
        item = QtWidgets.QTableWidgetItem()
        self.tempCloneTableWidget_2.setHorizontalHeaderItem(8, item)
        item = QtWidgets.QTableWidgetItem()
        self.tempCloneTableWidget_2.setHorizontalHeaderItem(9, item)

        item = self.tempCloneTableWidget_2.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow", "Username"))
        item = self.tempCloneTableWidget_2.horizontalHeaderItem(1)
        item.setText(_translate("MainWindow", "Password"))
        item = self.tempCloneTableWidget_2.horizontalHeaderItem(2)
        item.setText(_translate("MainWindow", "Email"))
        item = self.tempCloneTableWidget_2.horizontalHeaderItem(3)
        item.setText(_translate("MainWindow", "Email_password"))
        item = self.tempCloneTableWidget_2.horizontalHeaderItem(4)
        item.setText(_translate("MainWindow", "Cookie"))
        item = self.tempCloneTableWidget_2.horizontalHeaderItem(5)
        item.setText(_translate("MainWindow", "Token"))
        item = self.tempCloneTableWidget_2.horizontalHeaderItem(6)
        item.setText(_translate("MainWindow", "Profile Status"))
        item = self.tempCloneTableWidget_2.horizontalHeaderItem(7)
        item.setText(_translate("MainWindow", "Proxy"))
        item = self.tempCloneTableWidget_2.horizontalHeaderItem(8)
        item.setText(_translate("MainWindow", "Received Jobs"))
        item = self.tempCloneTableWidget_2.horizontalHeaderItem(9)
        item.setText(_translate("MainWindow", "Status"))

        for i, width in enumerate(column_widths):
            self.tempCloneTableWidget_2.setColumnWidth(i, width)

        # Iterate through the items and print them
        for i in range(self.category.count()):
            item_text = self.category.itemText(i)
            temp_category.addItem(item_text)

        def getSelectedRows():
            selected_rows = set()
            for item in self.tempCloneTableWidget_2.selectedItems():
                selected_rows.add(item.row())
            return selected_rows



        temp_category.currentTextChanged.connect(self.update_temp_clone_table)

        tab_category_save_button = QPushButton('Lưu', tab_add_by_category)
        tab_category_save_button.clicked.connect(lambda: self.cloneAccountByCategory(temp_category.currentText(), getSelectedRows()))
        tab_category_save_button.setGeometry(QtCore.QRect(6, 330, 260, 25))

        # Set up the layout
        layout_2 = QGridLayout()
        layout_2.addWidget(temp_category, 0, 0, 1, 2)
        layout_2.addWidget(self.tempCloneTableWidget_2, 1, 0, 1, 7)
        layout_2.addWidget(tab_category_save_button, 3, 0, 1, 2)

        tab_add_by_category.setLayout(layout_2)

        # Update temp table with the first time when show dialog
        all_data = {}
        for account_obj in self.accounts.values():
            all_data.update(account_obj)
        self.add_accounts_to_temp_clone_table(all_data)

        # Show the dialog
        dialog.exec_()

        

    def t3_ShowDialogConfigDevices(self):
        _translate = QtCore.QCoreApplication.translate

        # self.innerWorkTabWidget.addTab(self.tab_3, "")
        
        # Create a dialog
        dialog = QDialog()
        dialog.setWindowTitle('Thiết Lập Devices')
        dialog.setGeometry(450, 180, 1000, 390)  # Set the size of the dialog

        # The Temporary Table Widget
        self.deviceTable = QtWidgets.QTableWidget(dialog)
        self.deviceTable.setGeometry(QtCore.QRect(180, 130, 411, 192))
        self.deviceTable.setObjectName("deviceTable")
        self.deviceTable.setColumnCount(10)
        self.deviceTable.setRowCount(10)


        item = QtWidgets.QTableWidgetItem()
        self.deviceTable.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.deviceTable.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.deviceTable.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.deviceTable.setHorizontalHeaderItem(3, item)
        item = QtWidgets.QTableWidgetItem()
        self.deviceTable.setHorizontalHeaderItem(4, item)
        item = QtWidgets.QTableWidgetItem()
        self.deviceTable.setHorizontalHeaderItem(5, item)
        item = QtWidgets.QTableWidgetItem()
        self.deviceTable.setHorizontalHeaderItem(6, item)

        save_button = QPushButton('Thiết lập')
        save_button.clicked.connect(lambda: self.addAccountsToDevices())

        item = QtWidgets.QTableWidgetItem()
        self.deviceTable.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.deviceTable.setHorizontalHeaderItem(1, item)

        item = self.deviceTable.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow", "Device ID"))
        item = self.deviceTable.horizontalHeaderItem(1)
        item.setText(_translate("MainWindow", "Connected number"))

        column_widths = [300, 300]
        for i, width in enumerate(column_widths):
            self.deviceTable.setColumnWidth(i, width)

        self.accountsPerDevicelabel = QLabel()

        # Set up the layout
        layout = QGridLayout()
        layout.addWidget(self.deviceTable, 0, 0, 5, 5)
        layout.addWidget(save_button, 5, 0, 1, 2)
        layout.addWidget(self.accountsPerDevicelabel , 5, 4, 1, 1)
        

        dialog.setLayout(layout)

        # Update temp table with the first time when show dialog
        phone_devices = self.phone_devices
        self.add_phone_to_device_table(phone_devices)
        
        # Show the dialog
        dialog.exec_()

    def update_temp_clone_table(self, category):
        
        if category == "All category":
            all_data = {}
            for account_obj in self.accounts.values():
                all_data.update(account_obj)

            self.add_accounts_to_temp_clone_table(all_data)

        else:
            # show accounts by category that them belong
            self.add_accounts_to_temp_clone_table(self.accounts[category])    

    def cloneAccountByCategory(self, curr_category, selected_rows):

        if curr_category == "All category":
            temp_accounts = self.get_all_accounts()
        else:
            temp_accounts = self.accounts[curr_category]
        
        if len(selected_rows) == 0:
            dup_count = self.count_duplicate_keys(self.cloned_accounts, temp_accounts)
            if dup_count > 0:
                confirm_status = self.show_confirm_dialog(question_text=f"Phát hiện {dup_count} tài khoản bị trùng lặp, bạn có muốn ghi đè?")
                if confirm_status == 1:
                    self.cloned_accounts.update(temp_accounts) # update all the cloned accounts
                elif confirm_status == 0:
                    # update only the cloned accounts that are not duplicated
                    dup_keys = set(self.cloned_accounts.keys()).intersection(set(temp_accounts.keys())) 
                    for dup_key in dup_keys:
                        temp_accounts.pop(dup_key)
                    self.cloned_accounts.update(temp_accounts)
            elif dup_count == 0:
                self.cloned_accounts.update(temp_accounts)
        else:
            all_keys = list(temp_accounts.keys())
            filtered_keys = [all_keys[i] for i in selected_rows]
            filtered_accounts = {key: temp_accounts[key] for key in filtered_keys}
            # self.cloned_accounts.update(filtered_accounts)

            dup_count = self.count_duplicate_keys(self.cloned_accounts, filtered_accounts)
            if dup_count > 0:
                confirm_status = self.show_confirm_dialog(question_text=f"Phát hiện {dup_count} tài khoản bị trùng lặp, bạn có muốn ghi đè?")
                if confirm_status == 1:
                    self.cloned_accounts.update(filtered_accounts) # update all the cloned accounts
                elif confirm_status == 0:
                    # update only the cloned accounts that are not duplicated
                    dup_keys = set(self.cloned_accounts.keys()).intersection(set(filtered_accounts.keys())) 
                    for dup_key in dup_keys:
                        filtered_accounts.pop(dup_key)
                    self.cloned_accounts.update(filtered_accounts)
            elif dup_count == 0:
                self.cloned_accounts.update(filtered_accounts)

        self.add_accounts_to_worker_table(self.cloned_accounts)
        self.saveClonedJsonFile(self.cloned_accounts)

    def add_accounts_to_temp_clone_table(self, accounts: dict):
        self.tempCloneTableWidget_2.setRowCount(len(accounts))
        __sortingEnabled = self.tableWidget.isSortingEnabled()

        # Positions of field columns in the data table
        # column_order = ["tds_username", "tds_pass", "face_uid", "face_pass", "cookie", "token", "proxy", "user_agent", "tds_coins",  "status",  "action"]

        for row_index, account_data in enumerate(accounts.values()):
            self.add_row_to_temp_clone_table(row_index, account_data)

        self.tempCloneTableWidget_2.setSortingEnabled(__sortingEnabled)

    def add_phone_to_device_table(self, phones):
        self.deviceTable.setRowCount(len(phones))
        __sortingEnabled = self.tableWidget.isSortingEnabled()
        for row_index, phone_data in enumerate(phones.values()):
            self.add_row_to_device_table(row_index, phone_data)
        self.deviceTable.setSortingEnabled(__sortingEnabled)

        selected_indexes = [index.row() for index in self.t3tableWidget.selectionModel().selectedRows()]


        self.accountsPerDevicelabel.setText(f"(Accounts / Devices): {len(selected_indexes)}/{len(self.phone_devices)}")

    def selection_changed(self):
        selected_indexes = [index.row() for index in self.t3tableWidget.selectionModel().selectedRows()]
        if len(selected_indexes) > 0:
            self.t3_configureDeviceBtn.setEnabled(True)
        else:
            self.t3_configureDeviceBtn.setEnabled(False)

    def display_worker_result(self, result, row):
        print('result:', result)
        self.changeWorkerCellTableValue(row, self.worker_column_order.index('status'), newValue=str(result))

    def display_device_status(self, device: tuple, row):
        print('device', device)
        if device[1] == "free":
            try:
                keys = list(self.waiting_workers.keys())
                first_key = keys[0]
                self.threadpool_2.start(self.waiting_workers[first_key]) # run the first worker in the waitting workers list
                self.running_workers[first_key] = self.waiting_workers.pop(first_key)
                self.phone_devices["ce0817182b1ae49a0b"]["accounts"].append(first_key)
            except Exception as err:
                print(err)
    
    def addAccountsToDevices(self):
        selected_rows = [index.row() for index in self.t3tableWidget.selectionModel().selectedRows()]

        devices_count = len(self.phone_devices)
        accounts_count = len(self.selected_rows)

        accounts_per_device = devices_count // accounts_count













        for row_index in selected_rows:
            chosen_accounts = {}

            chosen_accounts = self.cloned_accounts
            keys = list(chosen_accounts.keys())
            chosen_account_key = keys[row_index]
            this_account = chosen_accounts[chosen_account_key]

            # Temporarily unused this
            # if this_worker.get('proxy') is None:
            #     self.show_error_dialog('Tài khoản này chưa có proxy, hãy thêm vào và thử lại!')
            # else:
            #     print(self.phone_devices)
                
            for i, key in enumerate(self.phone_devices):
                if self.phone_devices[key]['status'] == "free":
                    chosen_device = self.phone_devices[key]
                    break

            chosen_device = self.phone_devices[key]

            tiktok_worker = EmulatorWorker(chosen_device["name"], this_account)

            self.waiting_workers[this_account["username"]]= tiktok_worker


            tiktok_worker.signals.result.connect(lambda result, row=row_index: self.display_worker_result(result, row))
            tiktok_worker.signals.device_status.connect(lambda device, row=row_index: self.display_device_status(device, row))

            # self.threadpool_2.start(tiktok_worker)
        

        keys = list(self.waiting_workers.keys())
        first_key = keys[0]
        # self.threadpool_2.start(self.waiting_workers[first_key]) # run the first worker in the waitting workers list
        self.running_workers[first_key] = self.waiting_workers.pop(first_key)
        self.phone_devices["ce0817182b1ae49a0b"]["accounts"].append(first_key)

        print(self.phone_devices)
    

if __name__ == "__main__":

    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
